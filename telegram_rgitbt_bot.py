# -*- coding: utf-8 -*-
"""Telegram rgitbt bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hMEVI9anMbjxz0Y6VrBMYdsHXi8kGQZ7
"""

!pip install python-telegram-bot --upgrade

from typing import Final
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
import asyncio
import logging

# Enable logging for tracking bot activity and errors
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define your bot token as a constant
TOKEN: Final = '6085496671:AAF23dF_yCH48ztkMt2ZP6Spdf63TB2hNsQ'
BOT_USERNAME: Final = '@Tanay_chat_bot'

# Command Handlers
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /start command and welcomes the user."""
    await update.message.reply_text('Hello, Welcome to the RGITBT!')
    await update.message.reply_text('How may I help you?')
    await update.message.reply_text('Type "yes" to proceed.')

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /help command and provides bot assistance information."""
    await update.message.reply_text('I am the RGITBT Assistant. Please type something so I can assist you!')

async def custom_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles custom commands."""
    await update.message.reply_text('This is a custom command.')

# Custom function to process user input and return relevant responses from a dictionary
def handle_response(text: str) -> str:
    """Process the user message and return the appropriate response."""
    processed: str = text.lower()

    # Example of multi-level responses
    if 'yes' in processed:
      return 'a. General Information\nb. Student Services\nc. Academic Information\nd. Financial Information\ne. Feedback and Suggestions'

    if 'a' in processed:
      return '1. About the College\n2 Admission Information\n3 Departments and Courses\n4 Events and Announcements'

    if '1' in processed:
      return '@ History and Mission\n$ Campus Locations\n% Contact Information'

    if '@' in processed:
      return 'RGITBT (Rajiv Gandhi Institute of Biotechnology and Technology) was established with a vision to foster innovation and excellence in the field of biotechnology and technology. Founded with a mission to provide high-quality education, the institute focuses on creating skilled professionals who contribute to the scientific community and industries. RGITBT is committed to promoting research, technological advancements, and interdisciplinary collaboration, shaping future leaders in biotechnology and technology with a strong foundation in ethics, innovation, and social responsibility.'

    if '$' in processed:
      return 'The RGITBT (Rajiv Gandhi Institute of Biotechnology and Technology) campus is located in a serene environment that fosters academic and research excellence. Positioned in a well-connected area, the campus provides easy access to nearby cities while offering a peaceful setting for students and faculty. Equipped with modern laboratories, state-of-the-art facilities, and ample green spaces, the campus creates an ideal atmosphere for learning, innovation, and collaboration in the fields of biotechnology and technology\nhttps://maps.app.goo.gl/bNfpdSN7yfvRSXnE7'

    if '%' in processed:
      return 'contact-02024379013'

    if '2' in processed:
      return '! Undergraduate Admissions\n# Postgraduate Admissions'

    if '!' in processed:
      return 'i Application Process\nj Eligibility Criteria\nk Important Dates\n this information will provide you after the updates'

    if '#' in processed:
      return 'l Application Process\nm Eligibility Criteria\nn Important Dates\n this information will provide you after the updates'

    if '3' in processed:
      return '+ List of Departments\n= Course Catalog\n& Faculty Information\n this information will provide you after the updates'

    if '4' in processed:
      return 'o Upcoming Events\np Recent Announcements\nq Important Deadlines\n this information will provide you after the updates'

    if 'b' in processed:
      return '5 Library Services\n6 IT Services \n7 Counseling Services\n8 Housing and Accommodation\n9 Student Clubs and Organizations'

    if '5' in processed:
      return 'Library Hours - 9AM to 5PM\n http://www.bharatividyapeeth.edu/Students%2bCorner/Library/index.html'

    if '6' in processed:
      return 'High speed WIFI\n High Configuration Facilities\n Cloud storage'

    if '7' in processed:
      return 'interview prepration\n Skill Development\n '

    if '8' in processed:
      return 'Girls hostel\n Boys Hostel\n Monthly Mess'

    if '9' in processed:
      return 'Cultural Club\n Sports Club\n NSS Club\n Outreach Club\n Inovation Club'

    if 'c' in processed:
      return 'Academic Calendar\n Grades and Transcripts\n Class Schedules\n Academic Support'

    if 'd' in processed:
      return 'Tuition and Fees\n Financial Aid\n Billing and Payments'

    if 'e' in processed:
      return 'Dining Services\n Transportation\n Health and Wellness\n Safety and Security'

    return 'I do not understand what you wrote. Please try again.'

# Message Handler
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processes user messages and provides appropriate responses."""
    message_type: str = update.message.chat.type
    text: str = update.message.text

    # Log incoming message for debugging
    logger.info(f'User ({update.message.chat.id}) in {message_type}: "{text}"')

    # Get the response based on the user's message
    response: str = handle_response(text)
    logger.info(f'Bot response: {response}')

    # Send the response to the user
    await update.message.reply_text(response)

# Error Handler
async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Logs errors caused by updates."""
    logger.error(f'Update {update} caused error {context.error}')

# Command to stop the bot gracefully
async def stop_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /stop command and stops the bot."""
    await update.message.reply_text('Stopping the bot...')
    await context.application.stop()
    logger.info("Bot has been stopped.")

# Main function to start the bot and add handlers
async def run_bot():
    logger.info('Starting bot...')

    app = Application.builder().token(TOKEN).build()

    # Add Command Handlers
    app.add_handler(CommandHandler('start', start_command))
    app.add_handler(CommandHandler('help', help_command))
    app.add_handler(CommandHandler('custom', custom_command))
    app.add_handler(CommandHandler('stop', stop_command))

    # Add Message Handler
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Add Error Handler
    app.add_error_handler(error)

    # Start the bot and begin polling
    await app.initialize()
    logger.info('Polling started...')
    await app.start()
    await app.updater.start_polling()

    # Run until cancelled
    await app.idle()

# Entry point to start the bot
if __name__ == '__main__':
    try:
        # Check if an event loop already exists (useful in some environments like Jupyter)
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # If the event loop is already running, create a task for the bot
            loop.create_task(run_bot())
        else:
            # Otherwise, run the bot normally
            asyncio.run(run_bot())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot terminated.")

